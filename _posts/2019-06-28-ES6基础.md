---
layout: post
#标题配置
title:  ES6基础
#时间配置
date:   2019-10-14 13:08:00 +0800
#大类配置
categories: JavaScript
#小类配置
tag: ECMAScript
---

* content
{:toc}

ECMAScript-let和const详解
=====================

let只适用于当前块级作用域
----------------

```js
{
    let a=1;
    {
        console.log(a);//正常输出
        let b = 2;
    }
    console.log(b);//超出了b的块级作用域，输出错误
}
```

用let或者const声明的变量不能被重新声明
------------------
```js
    let son = 'son';
    let son = 'son2';//这句就会报错
```

let 不存在变量提升
----------------

var~

```js
    console.log(dad);
    var dad = 'dad!';

```
相当于

```js
    var dad;
    console.log(dad);
    dad = 'dad!';
```

let~

```js
    console.log(dad);
    let dad = 'dad!';
//报错 dad is notDefind
```

const
--------------
常量必须在声明的时候赋值（常量的初始化），常量是不可变的

常量声明后不能被修改
-----------------

```js
const NAME = 'xiaoming';

NAME = 'xiaohong';//报错
```

常量是引用类型的时候，可以修改该引用类型
--------------------------
1、以对象的形式进行修改

```js

const xiaoming ={
    age: 14;
    name:'小明'
}
console.log(xiaoming);
xiaoming.age=22;
console.log(xiaoming);
```
这个是可以成功把age的值改变的。

2、以push的形式改变值

```js
const ARR =[];
ARR.push(1);
console.log(ARR);

```
如果想要防止常量被修改，用Object.freeze()

```js

const xiaoming ={
    age: 14;
    name:'小明'
}
console.log(xiaoming);
Object.freeze()
xiaoming.age=22;
console.log(xiaoming);
```
这里的age值不会改变

解构赋值
======================

数组的结构赋值
-----------------------------
简单的数组解构：

```js
const arr=[1,2,3,4];
let [a,b,c,d] = arr;
```
更复杂的解构赋值

```js
const arr = ['a','b',['c','d',['e','f','g']]];
const [ , , g] = ['e','f','g'];
```

扩展运算符 ...

```js
const arr = [1,2,3,4];
const [ a, b, ...c] = arr;
```

对象的结构赋值
-------
```js
const player = {
    nickname:'sally',
    master:'long',
    skill:[{
        skillName:'1',
        mp:'100',
        time:2000
    },{
        skillName:'2',
        mp:'100',
        time:2000
    },{
        skillName:'3',
        mp:'100',
        time:2000
    }]
}
const {nickName} =player;//属性名与对象中的属性名要完全一样

const {skill:[skill1,{skillName}] } = player;//skill1是skill第一个数组，这里的skillname是数组中的二个里面的值，

const {skill:[skill1,{skillName},{skillName:skName}]}//由于const和lei一样不能重复起名变量，所以给第三个数组的skillName起名魏skName

```

结合扩展运算符

```js
const obj = {
    saber:'aer',
    archer:'wg',
    lancer:'std'
}
const {saber,...oh} = obj
```
使用场景：

![vue](https://raw.githubusercontent.com/Sallyfafafa/Sallyfafafa.github.io/master/images/es61.png)

数值与布尔结构赋值
-----------
```js
const {valueOf : vo} =1;
const {toString: ts} = false;
```

解构赋值的应用
------
1、交换两个值： [y,x] = [x,y];
2、提取json数据，const {name1 , name2} = pakJson;
3、遍历Map结构：for (let [k, v] of Map) {}  k是key值，v是value。



promise
============

定义
---------
用来表示一个异步操作的最终状态。
（完成或失败）以及它返回的值

简单的promise使用
-------
```js
// 方法 用于请求数据(模拟)
function f() {
	return new Promise(resolve => {
		setTimeout(function() {
			resolve();
		}, 1000);
	})
}

f()
	.then(function() {//这里的function是上边声明的resolve
		console.log(1);
		return f();//继续使用then的话必须要先返回promise的实例
	})
	.then(function() {
		console.log(2);
		return f();
	})
	.then(function() {
		console.log(3);
	})
```
实例用动画，一步一步动
```js

function moveTo(el, x, y) {
	return new Promise(resolve => {
		el.style.transform = `translate(${x}px, ${y}px)`;
		setTimeout(function() {
			resolve();
		}, 1000);
	});
}


let el = document.querySelector('div');

document.querySelector('button').addEventListener('click', e => {
	moveTo(el, 100, 100)
		.then(function() {
			console.log('第一次移动');
			return moveTo(el, 200, 200);
		})
		.then(function() {
			console.log('第二次移动');
		})
		.then(function() {
			console.log('第二次移动');
		});
});
```

编程练习：
```js

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.js"></script>
    <script type="text/javascript">
    
    function cook() {
        console.log('开始做饭。');
        var p = new Promise(function(resolve, reject){ 
            setTimeout(function() {
                console.log('做饭完毕！');
                resolve('鸡蛋炒饭');
            }, 1000);
        });
        return p;
    }
    
    function eat(data) {
        console.log('开始吃饭：' + data);
        var p = new Promise(function(resolve, reject) {
            setTimeout(function() {
                console.log('吃饭完毕!');
                resolve('一块碗和一双筷子');
            }, 2000);
        });
        return p;
    }
    function wash(data) {
        console.log('开始洗碗：' + data);
        var p = new Promise(function(resolve, reject) { 
            setTimeout(function() {
                console.log('洗碗完毕!');
                resolve('干净的碗筷');
            }, 2000);
        });
        return p;
}

cook()
.then(function (e) {
return eat(e);
}).then((function (e) {
return wash(e);
})).then(function (e) {
console.log(e)
});
//补充代码
</script>
</body>
</html>
```

错误处理
-----------

用reject捕获错误

```js
function f(value){
    return new Promise((resolve,reject)=>{
        if(value){
            resolve();//成功时回调的函数
        }
        else
        {
            1.
            reject();//失败时回调的函数
            2.
            reject(404);//传入参数,只能传递一个参数，第二个是拿不到的
        }
    })
}
//调用
f(false).then(
    ()=>{
        console.log('succes');
    },
    1.
    ()=>{
        console.log('faild');
    }
    2.
    e =>{
        console.log(e);
    }
)
```

catch使用实例的catch方法 可以捕获错误
----------
```js
f(true)
  .then(data => {
    console.log(data);
    return f(false);//错误实例，下边正确的promise不会被输出，直到catch捕获
  })
  .then(() => {
    console.log('我永远不会被输出');
  })
  .then(() => {

  })
  .catch(e => {
    console.log(e);
    return f(false) ;//这里会报一个错误，是promise没有解决的异常处理。
  });
```

 finally
 --------
 不论成功还是失败 finally中的内容一定会执行

```js
f(true)
  .then(data => {
    console.log(data);
    return f(false);
  })
  .catch(e => {
    console.log(e);
    return f(false);
  })
  .finally(() => {
    console.log(100);
  });
```
promise的三种状态
---------

pending：进行中  fulfilled：成功  rejected：失败

状态不可逆，只能从进行中变成成功或者失败。

promise.all方法
---------

他能把多个promise包装成一个新的promise实例。

多个promise实例中，有全部成功或者有一个失败，最后执行promise.all时就返回成功和失败。

```js
let p = Promise.all([]);
//如果promise传的是一个空数组，则回调成功
p.then(() => {
  console.log('succed');
}, e => {
  console.log(e);
});

```
promise.race方法
-----------

哪个参数结果获得的快，就立即执行promise.race，然后再执行后边的实例。

如果传入一个空数组，则被挂起，什么输出都没有。

promise.all的案例
---------

页面中有个板块 需要多张图片加载完之后才能进行展示
```js
const loadImg = src => {
	return new Promise((resolve, reject) => {
		const img = new Image();

		img.src = src;

		img.onload = void resolve(img);
		img.onerror = void reject('加载失败');
	});
};

const imgs = [
	'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1526734981&di=fe12efe9e3a76bd3bb5ac202a3c76823&imgtype=jpg&er=1&src=http%3A%2F%2Fd15.lxyes.com%2F15xm%2Fact%2F20151105%2F20%2F99112408.jpg',
	'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1252816855,3131381110&fm=27&gp=0.jpg',
	'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906477750,651116720&fm=27&gp=0.jpg'
];
//map首先遍历整个imgs数组，把数组项传给loadImg，然后返回一个新的promise实例作为数组项

Promise.all(imgs.map(src => loadImg(src))).then(arr => {
	console.log(arr);
});
```


