---
layout: post
#标题配置
title:  react 核心知识学习
#时间配置
date:   2021-03-30 09:25:00 +0800
#大类配置
categories: react
#小类配置
tag: 知识点
---

* content
{:toc}

class 类式组件
========

this 指向问题
-----

· render 里面的 this 指组件实例对象

```js
class Weather extends React.components {
    // this 指向实例对象
    // 构造器调用几次 --- 1次
    constructor (props) {

    }
    // this 指向实例对象
    // render 调用几次 --- 1+n次
    render () {
    
    }
    // this 指向原型
    changeWeather() {
    }
    // 类中写赋值语句，相当于给 实例对象 增加一个属性
    state = { isHot: false, wind: '微风'}

    // 通过 箭头函数，定义新的函数变量
    changeWeather2 = ()=>{
        // 这个里面的 this 指向实例对象
    }
}

```

props
----
React.components 的实例，已经为我们提供了 state，props...。
我们在创建类的时候，react 会从我们的组件中，帮我们 new 的时候 查找我们传递的 props，并且带给子组件。

拓展知识：对象浅拷贝-展开运算符: 只拷贝第一层
```js
const obj1 = {name: 'sally', age: 18};
const obj2 = {...obj1}
```

批量传递属性：
```js
<Weather {...obj1}/>
```

对标签属性进行限制：
```js
// 在 class 类外边指定，或者函数外边指定
// 指定属性标签值类型
Weather.proptypes = {
    name: Proptypes.string.isRequire
}
// 指定属性标签默认值
Weather.defaultProps = {
    age: 10
}

// 在 class 类里面指定
class Weather extends React.components {
    // 指定属性标签值类型
    static proptypes = {
        name: Proptypes.string.isRequire
    }
    // 指定属性标签默认值
    static defaultProps = {
        age: 10
    }
}
```




props 只读，不可写。

给类本身加属性：
```js
class Person extends React.components {
    static demo = 100
}
// 相当于
class Person extends React.components {

}
Person.demo = 100
```

构造器函数：
```js
constructor(){
    // 调用实例上的 this.props 是 undefined
}
constructor(props){
    super(props);
    console.log(this.props);
    // 调用实例上的 this.props 值是 props
}
```


refs
----
组件内的标签可以定义 ref 属性来标识自己。


字符串形式的 ref：（不被推荐使用，欲废弃，存在一些效率问题，效率不高）
```js
class Demo extends React.components {

    showData = ()=>{
        const { div1 } = this.refs;
        // 这里的 div1 是 节点 div 的实际 dom 节点
        console.log('div1', div1);
    }

    render(){
    
        return (
            <div ref="div1" onClick={showData}></div>
        )
    }
}
```

回调形式的 ref：
```js
class Demo extends React.components {

    showData = ()=>{
        const { div1 } = this;
        // 这里的 div1 是 节点 div 的实际 dom 节点
        console.log('div1', div1);
    }

    render(){
    
        return (
            // 回调函数概念：1、你定义的函数2、你没调用3、函数最终执行了
            <div ref={currentNode => {
                // 执行 jsx 时， 看到 函数式的 ref ，执行回调，把 ref 的 dom 实例对象放进去

                // currentNode 就是 ref 的 dom 节点实例
                this.div1 = currentNode;
            }} onClick={showData}></div>
        )
    }
}
```

回调 ref 回调执行次数：

