---
layout: post
#标题配置
title:  12月学习计划之-小程序组件单元测试
#时间配置
date:   2019-12-06 15:33:00 +0800
#大类配置
categories: 单元测试
#小类配置
tag: 小程序
---

* content
{:toc}


对小程序的组件测试，首先要想方法引入测试的组件，然后对组件中的某些元素进行测试。

使用引入的miniprogram-simulate的api



behavior（definition）
-----
注册并返回行为对象，支持字段和小程序 Behavior 构造器参数一致。

```js
const behavior = simulate.behavior({
    /* 小程序 behavior 支持的定义段 */
});

```


load
======
加载自定义的组件，返回的是一个componentId。可以传入自定义组件路径或者传入自定义组件对象（behavior）


load(componentPath, tagName, options)
--------

componentPath: 路径需是绝对路径。

```js
const path = require('path');
global.dist = `${path.resolve(__dirname, './dist')}`;
const id = simulate.load(`${dist}/pages/live/components/redPacket/index`)
```

tagName:（选填）自定义组件被实例化后的标签名。不传则默认是main

```js
const id = simulate.load(`${dist}/pages/live/components/redPacket/index`, 'redPacket')
```
options:（选填）加载自定义组件时传入的一些配置参数

load(definition)
----------

definition：自定义组件的定义对象，除了小程序本身支持的字段外，还支持：

id：（可选）传了就代表使用的全局组件，不需要用usingComponents引入

tagName：（可选）组件实例化的名字

template：组件对应的wxml内容

usingComponents：使用到的自定义组件映射表

behaviors：behavior 的用法和小程序类似

options： 配置对象，支持小程序自定义组件 options 定义段支持的所有字段

options.classPrefix	：组件样式的私有化前缀，默认是空串，即没有前缀

```js
simulate.load({
    id: 'view',
    tagName: 'wx-view',
    template: '<div><slot/></div>'
}); 

let childId = simulate.load({
    tagName: 'xxx',
    template: '<view><slot/></view>', // 直接使用全局组件
});

let id = simulate.load({
    template: '<child>123</child>',
    usingComponents: {
        'child': childId, // 声明要使用的组件，传入组件 id
    },
    behaviors: [behavior],
    options: {
        classPrefix: 'xxx',

        /* 其他小程序自定义组件支持的 option，比如 addGlobalClass 等 */
    },

    /* 其他小程序自定义组件支持的定义段，比如 methods 定义段等 */
});
```

调用组件过后就要考虑渲染的问题。

render
======
渲染自定义组件

render(componentId, properties)
------
componentId：调用 load 接口返回的 id。

properties：可选字段，创建组件实例时，由组件接收的初始 properties 对象。

```js
const _comp = simulate.render(id)
```

match
======
组件渲染好之后，就要开始测试它与预想的是否一致。

match(dom, html)
-------

检查 dom 节点的内容是否符合给定的 html 结构，通常用于比较渲染结果是否符合预期。
```js
const isMatch = simulate.match(dom, '<view>123</view>')
```

async
====
有的时候不想让他们立马就进行后续的操作，这时要有一个作为延迟用的代码。

async sleep(timeout)
-----
延迟一定时间执行后续代码，主要用于处理需要等待一定时间才能往后续进行操作的情况。此方法会返回一个 promise 对象。

```js
await simulate.sleep(300) // 等待 300ms 后再继续后续代码的执行
```

scroll
=====
单元测试中，滑动的操作实现不了，这时就可以用这个接口scroll，模拟滚动。

scroll(component, destOffset, times, propName)
------

destOffset 为滚动的目标数值；
times 为触发 scroll 事件的次数，默认为 20 次；
propName 为滚动字段，默认为 scrollTop。

```js
simulate.scroll(component, 100, 15) // 纵向滚动到 scrollTop 为 100 的位置，期间会触发 15 次 scroll 事件

```

Component
======
选择组件实例对应的节点，对象和instance

方法：
querySelector(selector)
-----
获取符合给定匹配串的第一个节点，返回 Component 实例。
```js
const childComp = comp.querySelector('#a')
```

querySelectorAll(selector)
-----
获取符合给定匹配串的所有节点，返回 Component 实例列表

```js
const childComps = comp.querySelectorAll('.a')

```

setData(data, callback)
---------
调用组件实例的 setData 方法.

```js
comp.setData({ text: 'a' }, () => {})

```

dispatchEvent(eventName, options)
------
用于模拟触发该组件实例节点上的事件。
```js
// 触发组件树中的节点事件
comp.dispatchEvent('touchstart', {
  touches: [{ x: 0, y: 0 }],
  changedTouches: [{ x: 0, y: 0 }],
})

// 触发组件树中的节点自定义事件
comp.dispatchEvent('customevent', {
  touches: [{ x: 0, y: 0 }],
  changedTouches: [{ x: 0, y: 0 }],
  /* 其他 CustomEvent 构造器支持的 option */
})
```

triggerLifeTime(lifeTime)
-----
触发组件实例的生命周期钩子。

```js
comp.triggerLifeTime('moved')
```












