---
layout: post
#标题配置
title:  《你不知道的JavaScript》有感-编译、词法作用域
#时间配置
date:   2020-01-02 10:20:00 +0800
#大类配置
categories: JavaScript
#小类配置
tag: 你不知道的JavaScript读后感
---

* content
{:toc}

比较欣赏的是作者的一种思想，那种对于新知识求贤若渴的态度。当我们是孩子的时候，对世界充满好奇，恨不得问遍全世界，什么都是什么来的，十万个为什么，那时候的求知欲，我现在似乎很缺失。

编译
====

编译原理
----
各个语言都有编译原理，
传统语言在执行前会经历三个过程：分词/词法分析，解析/语法分析，代码生成。

但是js会比这三个过程要复杂的多。

var a = 1；的编译过程
------

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3节）。

总结就是：先声明一个变量，命名为a；在给a赋值2

LHS和RHS
-----
在我看来LHS更适合于赋值，函数定义等等。。（给变量赋值）

RHS更加适合引用，如console.log(...)，函数声明。（获取变量的值）

若要对一个未定义的变量进行RHS查询，引擎就会抛出 `ReferenceError`
异常。（重要的异常类型）

在程序的非严格模式下，对一个未定义的变量进行LHS的查询，如果找不到该变量，则会隐式创建一个全局变量，作为LHS引用的目标作为标识符。或者抛出ReferenceError异常。

词法作用域
========

词法阶段
-----
这时会把代码作用域分成一个个的代码气泡。不存在一个气泡的部分被两个大气泡同时包裹。每个气泡都是被它的父级气泡单独包裹的。

查找
----
作用域的查找，会在第一个匹配到的标识符处停止查找。

由于变量的多层遮蔽效应，外层的同名标识符被遮盖。所以想要直接在内部访问外边的同名标识符，可以直接 `window.a `

欺骗词法
-----
欺骗词法就是为了打破原先的词法作用域（遮蔽效应）来决定的。

eval(...)欺骗的例子：
```js
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
eval通常被用来执行动态创建的代码。

尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var
声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作
用域中。

本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作
用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

with欺骗的例子：
```js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}
var o1 = {
    a: 3
};
var o2 = {
    b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```

不推荐使用的原因：eval(..) 和 with 会被严格模式所影响（限
制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
eval(..) 也被禁止了。

性能
------
js在编译阶段，对当前代码进行词法分析。但是当这个阶段进行时遇到了eval和with，这时还无法断定进来的参数是什么，他们会怎么对词法作用域进行修改。

隐藏内部实现
----
```js
function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }
    var b;
    b = a + doSomethingElse( a * 2 );
    console.log( b * 3 );
}
doSomething( 2 ); // 15
```
功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会
依此进行实现。

变量冲突：
```js
function foo() {
    function bar(a) {
        i = 3; // 修改 for 循环所属作用域中的 i
        console.log( a + i );
    }
    for (var i=0; i<10; i++) {
        bar( i * 2 ); // 糟糕，无限循环了！
    }
}
foo();
```
为解决变量冲突，可以采用全局命名空间，就是定义一个对象，对象内部放置需要访问的函数和变量。或者通过模块管理规避冲突。

块级作用域
-------
能够导致块级作用域的方式有很多。例如：with、try/catch里面的catch、let可以把变量隐式的变成块级作用域、const定义块作用域







