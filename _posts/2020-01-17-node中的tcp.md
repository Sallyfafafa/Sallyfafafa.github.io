---
layout: post
#标题配置
title:  node中的TCP-net，HTTP，connect
#时间配置
date:   2020-01-17 14:46:00 +0800
#大类配置
categories: Node
#小类配置
tag: Node中TCP
---

在学计算机网络原理时，老师就有讲到过TCP与UDP。 

TCP
-------
特性：
1、 面向连接的通信和保证顺序的传递
2、 面向字节流
3、 可靠
4、 流控制（控制两台计算机的传输数据平衡）
5、 拥堵控制

基于TCP的聊天程序-服务器
=======
现在需要的功能是：
1、成功连接到服务器，服务器会提示连接成功欢迎。提示需输入用户名，同时可以得知有多少其他客户端也连接到了服务器。
2、 输完用户名后，按下回车连接成功。
3、然后就可以与其他客户端进行沟通，用户输入内容按下回车，别的客户端就可以接收到。

创建模块
----
国际惯例，先来一个package.json
```js
{
    "name": "tcp-chat",
    "description": "our first tcp-server",
    "version": "0.0.1"
}
```
`npm install`一下

理解`net.server API`
---------
创建一个index.js
```js
/**
 * Module dependencies.
 */

var net = require('net')

/**
 * Create server.
 */

var server = net.createServer(function (conn) {
  // handle connection
  console.log('\033[90m   new connection!\033[39m');
});

/**
 * Listen.
 */

server.listen(3000, function () {
  console.log('\033[96m   server listening on *:3000\033[39m');
});
```
输入node index.js

打印：server listening on *:3000
此时如果有客户端接入server时，会打印new connection！

接收连接
-----
在createServer内进行修改，加一个计数器，每当有一个新的客户端进来，都会增加一个连接数并把它打印。
```js
var count = 0;
var server = net.createServer(function (conn) {
  conn.write(
      '\n > welcome to \033[92mnode-chat\033[39m!'
    + '\n > ' + count + ' other people are connected at this time.'
    + '\n > please write your name and press enter: '
  );
  count++;

  conn.setEncoding('utf8');
  conn.on('data', function (data) {
    console.log(data);
  });
  conn.on('close', function () {
    count--;
  });
});
```
用户连接情况
------
同样是修改createServer内的内容。有客户端进来，会打印欢迎语，并让客户端注册昵称。没有昵称的，提示。有昵称的，提示别的客户端，有人进来了。如果有人出去，则用户连接总数改变。
```js

var count = 0
  , users = {}

/**
 * Create server.
 */

var server = net.createServer(function (conn) {
  conn.write(
      '\n > welcome to \033[92mnode-chat\033[39m!'
    + '\n > ' + count + ' other people are connected at this time.'
    + '\n > please write your name and press enter: '
  );
  count++;

  conn.setEncoding('utf8');

  // the nickname for the current connection
  var nickname;

  conn.on('data', function (data) {
    // we remove the "enter" character
    data = data.replace('\r\n', '');
    var nickname;

    function broadcast (msg, exceptMyself) {
        for (var i in users) {
        if (!exceptMyself || i != nickname) {
            users[i].write(msg);
        }
        }
    }
    // the first piece of data we expect is the nickname
    if (!nickname) {
      if (users[data]) {
        conn.write('\033[93m > nickname already in use. try again:\033[39m ');
        return;
      } else {
        nickname = data;
        users[nickname] = conn;

        for (var i in users) {
          users[i].write('\033[90m > ' + nickname + ' joined the room\033[39m\n');
        }
      }
    } else {
      // otherwise we consider it a chat message
      for (var i in users) {
        if (i != nickname) {
          users[i].write('\033[96m > ' + nickname + ':\033[39m ' + data + '\n');
        }
      }
    }
  });
    // 关闭连接，则清除这个人的信息。
  conn.on('close', function () {
    count--;
    delete users[nickname];
    broadcast('\033[90m > ' + nickname + ' left the room\033[39m\n'); // 广播
  });

});
```

实现一个TCP客户端
=======
IRC
-----
IRC简称为：因特网中继聊天，它也是一种常用的，基于TCP的协议。
irc的特点，中转，在AB聊天之间有一个中转站，互相聊天发送的内容其实都是先发给中转站，然后再发给接收方。

创建模块
----
国际惯例，先来一个package.json
```js
{
    "name": "irc-client",
    "description": "our first TCP client",
    "version": "0.0.1"
}
```
理解`net.STREAM API`
---------
与createServer一样，new API提供了一种名为connect新的方法
`net.connect(port[[,host], callback])`

他如果提供了回调函数，这个回调函数相当于方法返回对象上的connect事件。
```js
1/ 
var client = net.connect(3000, 'localhost');
client.on('connect', function(){
});
2/ 
net.connect(3000, function() {
});
```
ps：需要irc客户端。

HTTP
=======
http协议又是超文本传输协议。
想要在这篇学到的东西：以前每当我们更改完文件都要重启一次node，学完之后，做到不需重启，自动编译。

当用户浏览一个网站时，用户代理（浏览器）会创建一个请求，该请求通过TCP发送给Web服务器，随后服务器会给出响应。

```js
var http = require('http');
// 创建服务器
var server = http.createServer(function(req, res) {
  res.writeHead(200, {'Content-Type':'text/html'}); // 响应头 code,响应文本类型，
  res.end('Hello word');
}).listen(3000);
```
看一个进阶版的例子
```js
var http = require('http');
// 创建服务器
var server = http.createServer(function(req, res) {
  res.writeHead(200, {'Content-Type':'text/html'}); // 响应头 code,响应文本类型，
  res.wirte('Hello'); // 首次先发送的内容第一块包含响应头以及响应数据
  setTimeout(function(){
    res.end('Hello word'); // 然后发送块 内容以结束这一响应（结束后就不会再往里面发送此响应数据了）
  }, 300);
}).listen(3000);
```
这段代码增加了一个异步的操作。正常情况，连接一个server时，可以在end之前操作多次write方法来发送数据。
响应头里的Transfer-Encoding默认为chunked。是指数据是一块一块的发送。
而且由于要尽可能快去响应客户端，在首次调用write时，会把响应头以及响应数据一并发送出去。

进一步演进
```js
var http = require('http');
var fs = require('fs');
// 创建服务器
var server = http.createServer(function(req, res) {
  res.writeHead(200, {'Content-Type':'image/png'}); // 响应头 code,响应文本类型，
  var stream = fs.createReadStream('image.png');
  
  res.wirte('Hello'); // 首次先发送的内容第一块包含响应头以及响应数据
  setTimeout(function(){
    res.end('Hello word'); // 然后发送块 内容以结束这一响应（结束后就不会再往里面发送此响应数据了）
  }, 300);
}).listen(3000);

```


connect
=========
connect是一个基于http服务器的工具集，它提供了一种新的组织代码的方式来与请求，响应对象进行交互，这里称为中间件。

先用http实现一个静态网页的显示
------
```js
var http = require('http');
var fs = require('fs');

// 创建服务器
var server = http.createServer(function(req, res) {
    // 检查服务器目录是否与文件夹下目录匹配
    if('GET' == req.method && '/images' == req.url.substr(0,7)) {
        fs.stat(__dirname + req.url, function (err, stat) {
            console.log('err:',err);
            if (err || !stat.isFile()) {
                //请求错误时的Status Code
              res.writeHead(404);
              res.end('Not Found');
              return;
            }
            // jpg类型的图片
            serve(__dirname + req.url, 'application/jpg');
        });
    } else if ('GET' == req.method && '/' == req.url) {
        // 入口配置
        serve(__dirname+'/index.html', 'text/html');
    } else {
        res.writeHead(404);
        res.end('Not Found!!~')
    }
    // 请求服务函数,告诉浏览器发送的资源类型
    function serve (path, type) {
        res.writeHead(200, { 'Content-Type': type });
        fs.createReadStream(path).pipe(res);
        // 这里的 createReadStream 会有另一种写法：
        // fs.createReadStream(path)
        // .on('data', function(){})
        // .end('data', function(){})
        // }
    }
});

// 监听3000端口
server.listen(3000);

```
这里的文件目录是如下图：
![](https://cdn.weipaitang.com/static/20200120819484c3-4e56-84c34e56-11d5-651ff0f3fcfc-W528H456)

网站样式：
![](https://cdn.weipaitang.com/static/20200120e911acef-ed85-acefed85-9433-2ccd3034dc3c-W2558H1448)

由于有的图片我放的不是jpg，代码会把不是jpg的图片给过滤掉。

用connect实现一个静态网页的显示
-------


